package cool.parser;

import java.util.ArrayList;
import beaver.*;
import cool.parser.ast.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "cool.grammar".
 */
public class SimpleParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjc0cK5iKHn$ypiz#kB0XuWLox78iWnnAK5LUkHH2lQ1IDHn9Dp67Y6T4OZSOeYSOZQeo" +
		"9nYjgel46yG11yK954Ln04L3HUCSZHl4MDPrVpzHyEz#n#pOcBy$dS#hzfwghgxgxglgRcV" +
		"waohtSFKNat2ScVUm#rXpk$$8Ir6BJ71DS7S3UlgMZD44ZhITFQ7#XaJfHOqpp15YfIhVIo" +
		"tYkX3vLXNAnb27p7AVrJDEiJZRcjy5riJH5arNLofp7gwDfdZ4oISFoke$SHze0NEibABLy" +
		"Hbsqlbk2z7n2gZRUMLUQRfrRX#yw7UWbwFcyRHTrTOjLuvOPBKcuVk3kCCs7K3EuFPO#p5i" +
		"kKwKsSekHcZKDJ28peNjO1#dxH7KaKHscd#g76goVw73zM4SeKfKsTZDqc$fg2xSq8UrZ$3" +
		"lkOPFIElnCZJhPBKejeMRt95ZgyweTOjddzLlQf4nUZwR2YzJDD6iIKdVZcxhvfdlVlQzwC" +
		"C9Bq9gyxL4wWJ7MkASJKa#JRdMtcBG2ckzMQ7OihKWjeMRTognFkwSIqkd6Rr0$argYdAw1" +
		"6f1QGl6kIJZHVTUY$BCsBudo0WtHD5siITRskR$UxvdYtBkxtDqUsZ$E$RC9wUl6UskMwVm" +
		"eGzsTkXoSnPv$Da#l9QGjZP#f1fCcQfZErodwjSxMgTemjQHd6lDD0jjgktXj#sadVQzaNt" +
		"nLkxXLsXMmDktiLa6pz3KtAvQozBZsTAkrXrjjxTNGJEtbPiPIbcvoDtfeNsk$RjISS5skg" +
		"qpwXcRe6irq3xe7OYJQ9atLeUphXyZjG$ecyVdrd#qUquObkLtebhk5Ei0z6kVsrOHqYF5Z" +
		"g4UYcwTZsGStmq$J6VfDQWdzFI7zrlWvxFj4DrU$m$vSDvVxxzsyr19w9I6TP$n2NMIws$H" +
		"7$2vnjt7$4vwlvEdbX7IPyR$e2jFDqL#nlz$DmNiOqijvUYaXNMtI0dUlIRFTVVZDWi$HZN" +
		"Y#bASN4z9Dnc$MF9DkqUrkjkRgBkxpyNmnJoyaf3kCtwcxJRf7zsg1xjTzMgW7zA1fcxYdJ" +
		"x67Z2$ImoOjrX8rwn4jrJ8jrwCjJpptN49wpFZZMc7IIgtMAZsf9xH6Jxb7JDl4$My9wMdZ" +
		"N2rIzaejwPb6SvAf$Tv9hkAzttBvlL$iqxiLdzJE#xGrzXV5BfCZzqP2vDfuLYgeHQ9j#Yo" +
		"LSFz8Y56CPwM2MH9jK$g4GMCyAnLuf4#OpxAkjn9Y5EDPgM2MjpHUFtTl9aJRU5Ogi7ypjl" +
		"zdGhIDvwMYrQB1lcIrxOlfIwlKgezsjw#07#bN6gJH#gLxsxsjuu2yv7bMicjuV1$hrhgrs" +
		"Ax5OcqiAoiLZ3us7hrNWKwnRdlrAAFjbPbjnxpqXpAMTMLqcvNHVQMCRYltddkFDST8v4JI" +
		"DcMiTtFlk7VeZv78YLJM#c3thdkN$XY9d4XbhI$bYoohgqLNgEbVeXcbqUu3zm6ZnaXahgr" +
		"raWA5VF5oMk0xkKhhnVgEwgJruvvwUcGztTHTcrA3dlG4#DJWCvwUAdLGDNjbSxxoElilTM" +
		"t0ryT6sbYRc7OeNrwzU4lqCSzwF9NtbBPYnQrvrkOzStZceFhOptjkIMHrhNesvJsJ20TO7" +
		"1qOep32#f886yczY33rdM0M0QCK#cvHrZUNyQqpY#tHjFYAdg34jvwdvm1yqvhupEJQoEyK" +
		"Hgzctm#AOqrdhBPnE#TNsrA7uN7yvMgPP27DwvXMyZf0$OhoMckprHJid92UYfBuaZ5QSbD" +
		"f5fwt#DQLhKd8Vgt8#APHJcBDfL6kXrKsolfyb3wwDCeU9L7Mq1CHOywYz9OXzueIopJ6#e" +
		"BSDzYg1kARHXImIq96h8ZtRdPLYKy7ynb7E$6fHjU7qqZ8VgZW5ztYa$nwwXanYDVcvsieM" +
		"Lir4KHKfZ2AcZ9HLCQ$gub5ba4RyHRNFzt5EUPBLbzBpq1$pZQFR0qZoyHcDbTV$FkNcIk8" +
		"ROA2t8OsKss#uZwprN6rnd6lBPFRT9UCoVZqOswVcxvaf7yPdyfy3LjsPNKxVOACpmxuv6A" +
		"V3cLzjiXdhkM9bCEdJ#opTLcVD9v##TzsRUnHHmRxGkLy#kVZwMm#NMdtHDEBdFTcTQK#ON" +
		"vjwLEhNnnb3LNfWNrKngUx#NH4d$Xqeg9#DzTIrOruFfJwR9BuEAx4nnLTsRrFAsTQzev9H" +
		"Nidu#dtJf6F1fRtIUrYdpR6$gBO5UJ8Qa6hlRNuB9NupsVvVAxhVsPViZSJ##9dORjY#jAg" +
		"p3VdSDwJ8$YU7zcUcccorQnDsuBHkzde6HqMYMviEMrcjctpKbdB$qf71CZbTjp$sxfKrnv" +
		"DQtD8pvoKdE$c0tzMwU1Fbs03C16C15F1qM0tS9OKp8AV3zzC2liYpmPtWcl0Ak3$a$YGVh" +
		"x9WofmAcZ4Td$uE32U$hEbw30uQmZsHPuEFmH#7fmpStGjVIU0YsaV24u4Pz2#0In27XB7e" +
		"8Xv0spq4dmUxUNm1#2qHRkI4sp57LBkLNWp$4ZuSu2mApWNLWJOtmlk0rVuOo9y3V3ZFWvG" +
		"1Q#1fu3lmpTO39Q2rVXl2bz7RBtXdu3DSUX9crDOi3toit1o4NO4tMZt0AEHcy3EyKbDuM3" +
		"u7jZTXBmhyX78VZnEJC4#$h28lW7i2NO7v2ay1Lm6Y35yZBZ8S$W6SSDpp1$repq6KBi8dZ" +
		"iD36Uz5y2Pks8Ks0LGonnpLtPdhal0pS2lvH5ygN#uDpAdxN0o89wGFHBotH5k3AXBU2YWV" +
		"k5#u03cmZSy6HmBg5TmCFmWS3eu5nm3ZcTUQXnU2gXdG4t2gm7v3nS27ylru3f07SAxWA$F" +
		"EIJYAcIVuoNm6M0OeAuXDGuN068CVNxzFnVlmUy1jmFsHBWCF0ZO8#5Am9u8NmVUxWNm8dW" +
		"Vi7V2Dy57n4CT8seNTQNDVeasX5FlYDz7I5uYDaZ4sJkYhb4NG6wYMZ00r07ES16vYgXnr1" +
		"$mUuc6WgtiTtUXvoPtIcKFjZTxJTHSmwr$QiRsYAojwPONjdCbDec#iYeZTpNRYunVMMeVJ" +
		"BU#YPcnPnQDsSFqSpFhMMoyodYTnVL9Pkphh6zePkpZogsxABQbcJ4M63#gTNl$N0gkBnFR" +
		"5333R0ulCy$BRQz3DsJaDrhai3wZdsXpTIcQUtnH#$IC$w2svmqRYzPvIbls6RjFC$FjL3J" +
		"cWSRFB5fNJP7TUUsPw$CAkwPgHnxke$ao6GttyaY#KVpRU0Hlo16SqaR4SiJRCqN05qe40j" +
		"wiaI7WFHiP0jwxaS7BeV6WgErvHMpdtn3#NwmXw8R0Hy57mRUaBq6WRNa1J4HkO5qDhAi1t" +
		"M3y1yV$mKXJD8YtYF$dC0GH23GfHXHp$n$F1FecnEVd4FWpVgJ9yCd6c#3RqBSDSYFV08ry" +
		"2pGoPYDpDk8$5ht76EosWszdV1nyfty3Bh9Q6G==");

	public SimpleParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // program = class_list.cl
			{
					final Symbol _symbol_cl = _symbols[offset + 1];
					final ArrayList cl = (ArrayList) _symbol_cl.value;
					 return new Symbol(cl);
			}
			case 1: // class_list = classdecl.cd class_list.cl
			{
					final Symbol cd = _symbols[offset + 1];
					final Symbol _symbol_cl = _symbols[offset + 2];
					final ArrayList cl = (ArrayList) _symbol_cl.value;
					 cl.add(cd); return new Symbol(cl);
			}
			case 2: // class_list = empty
			{
					 return new Symbol( new ArrayList() );
			}
			case 4: // expr = lexpr.le ASSIGN rexpr.re
			{
					final Symbol le = _symbols[offset + 1];
					final Symbol _symbol_re = _symbols[offset + 3];
					final Expr re = (Expr) _symbol_re.value;
					 ArrayList operands = new ArrayList(); operands.add(le); operands.add(re); return new AssignmentOperation(operands);
			}
			case 5: // expr = rexpr.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final Expr r = (Expr) _symbol_r.value;
					 return r;
			}
			case 6: // rexpr = IF LPAREN rexpr.cond RPAREN expr.m ELSE expr.e
			{
					final Symbol _symbol_cond = _symbols[offset + 3];
					final Expr cond = (Expr) _symbol_cond.value;
					final Symbol _symbol_m = _symbols[offset + 5];
					final Expr m = (Expr) _symbol_m.value;
					final Symbol _symbol_e = _symbols[offset + 7];
					final Expr e = (Expr) _symbol_e.value;
					 return new IfNode( cond, m, e);
			}
			case 7: // rexpr = WHILE LPAREN rexpr.cond RPAREN expr.e
			{
					final Symbol _symbol_cond = _symbols[offset + 3];
					final Expr cond = (Expr) _symbol_cond.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					 return new WhileNode( cond, e);
			}
			case 8: // rexpr = rel.r
			{
					final Symbol r = _symbols[offset + 1];
					 return r;
			}
			case 9: // rexpr = primary.p MATCH cases.c
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 3];
					final ArrayList c = (ArrayList) _symbol_c.value;
					 Expr e = (Expr) p.value; return new Match(e, c);
			}
			case 10: // rel = rel.r LE equiv.e
			{
					final Symbol r = _symbols[offset + 1];
					final Symbol e = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(r); operands.add(e); return new LessOrEqual(operands);
			}
			case 11: // rel = rel.r LT equiv.e
			{
					final Symbol r = _symbols[offset + 1];
					final Symbol e = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(r); operands.add(e); return new LessThan(operands);
			}
			case 12: // rel = equiv.e
			{
					final Symbol e = _symbols[offset + 1];
					 return e;
			}
			case 13: // equiv = equiv.e EQUALS sum.s
			{
					final Symbol e = _symbols[offset + 1];
					final Symbol s = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(e); operands.add(s); return new Equal(operands);
			}
			case 14: // equiv = sum.s
			{
					final Symbol s = _symbols[offset + 1];
					 return s;
			}
			case 15: // sum = sum.s PLUS product.p
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol p = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(s); operands.add(p); return new PlusOperation(operands);
			}
			case 16: // sum = sum.s MINUS product.p
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol p = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(s); operands.add(p); return new MinusOperation(operands);
			}
			case 17: // sum = product.p
			{
					final Symbol p = _symbols[offset + 1];
					 return p;
			}
			case 18: // product = product.p TIMES primary.i
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol i = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(p); operands.add(i); return new MultiplyOperation(operands);
			}
			case 19: // product = product.p DIV primary.i
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol i = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(p); operands.add(i); return new DivisionOperation(operands);
			}
			case 20: // product = primary.p
			{
					final Symbol p = _symbols[offset + 1];
					 return p;
			}
			case 21: // primary = LBRACE block.b RBRACE
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return (Expr)b;
			}
			case 22: // primary = LPAREN expr.e RPAREN
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 23: // primary = NULL
			{
					 return new NullNode();
			}
			case 24: // primary = LPAREN RPAREN
			{
					 return new Unit();
			}
			case 25: // primary = INTEGER.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					 return new IntegerNode(Integer.parseInt(i));
			}
			case 26: // primary = STRING.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final String s = (String) _symbol_s.value;
					 return new StringNode(s);
			}
			case 27: // primary = BOOLEAN.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Boolean b = (Boolean) _symbol_b.value;
					 return new BooleanNode(b);
			}
			case 28: // primary = MINUS primary.p
			{
					final Symbol p = _symbols[offset + 2];
					 ArrayList operands = new ArrayList() ; operands.add(p); return new UnaryMinusOperation(operands);
			}
			case 29: // primary = lexpr.e
			{
					final Symbol e = _symbols[offset + 1];
					 return e;
			}
			case 30: // primary = NOT primary.p
			{
					final Symbol p = _symbols[offset + 2];
					 ArrayList operands = new ArrayList() ; operands.add(p); return new UnaryNotOperation(operands);
			}
			case 31: // primary = primary.p DOT ID.id actuals.a
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol _symbol_id = _symbols[offset + 3];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final ArrayList a = (ArrayList) _symbol_a.value;
					 Primary pp = (Primary)p.value ; return new PrimaryActual(a,pp, id);
			}
			case 32: // primary = NEW TYPE.t actuals.s
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_s = _symbols[offset + 3];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Instance(t,s);
			}
			case 35: // ident = ID.id opt$actuals
			{
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					 return new Id(id);
			}
			case 36: // ident = THIS
			{
					 return new Id("this");
			}
			case 37: // block = st_list.el expr.e
			{
					final Symbol el = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 ArrayList es = (ArrayList) el.value; return new Block(es , e);
			}
			case 38: // block = empty
			{
					 return new Block();
			}
			case 39: // st_list = st_list.el new_var.ve SEMI
			{
					final Symbol el = _symbols[offset + 1];
					final Symbol ve = _symbols[offset + 2];
					 ArrayList es = (ArrayList) el.value; es.add(ve); return new Symbol(es);
			}
			case 40: // st_list = st_list.el expr.e SEMI
			{
					final Symbol el = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 ArrayList es = (ArrayList) el.value; es.add(e); return new Symbol(es);
			}
			case 41: // st_list = empty
			{
					 ArrayList el  = new ArrayList(); return new Symbol(el);
			}
			case 42: // new_var = VAR ID.id COLON TYPE.t ASSIGN expr.e
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_e = _symbols[offset + 6];
					final Expr e = (Expr) _symbol_e.value;
					 return new VarExpr( id, t, e);
			}
			case 43: // cases = LBRACE case_block.cb RBRACE
			{
					final Symbol _symbol_cb = _symbols[offset + 2];
					final ArrayList cb = (ArrayList) _symbol_cb.value;
					 return new Symbol(cb);
			}
			case 44: // case_block = CASE ID.id COLON TYPE.t ARROW block.b case_block.cb
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_cb = _symbols[offset + 7];
					final ArrayList cb = (ArrayList) _symbol_cb.value;
					 cb.add(new Case(id,t,b));return new Symbol(cb);
			}
			case 45: // case_block = CASE NULL ARROW block.b case_block.cb
			{
					final Symbol _symbol_b = _symbols[offset + 4];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_cb = _symbols[offset + 5];
					final ArrayList cb = (ArrayList) _symbol_cb.value;
					 cb.add(new Case(b));return new Symbol(cb);
			}
			case 46: // case_block = empty
			{
					 return new Symbol(new ArrayList());
			}
			case 47: // lexpr = SUPER DOT ID.id actuals.a
			{
					final Symbol _symbol_id = _symbols[offset + 3];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final ArrayList a = (ArrayList) _symbol_a.value;
					 return new SuperActual(id,a);
			}
			case 48: // lexpr = ident.id
			{
					final Symbol _symbol_id = _symbols[offset + 1];
					final Id id = (Id) _symbol_id.value;
					 return id;
			}
			case 51: // classdecl = CLASS TYPE.t varformals.v have_extends.e classbody.fl
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_v = _symbols[offset + 3];
					final ArrayList v = (ArrayList) _symbol_v.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Extends e = (Extends) _symbol_e.value;
					final Symbol fl = _symbols[offset + 5];
					 return new ClassNode(t, v, e, (ArrayList)fl.value);
			}
			case 52: // varformals = LPAREN RPAREN
			{
					 return new Symbol(new ArrayList());
			}
			case 53: // varformals = LPAREN var_list.vl RPAREN
			{
					final Symbol _symbol_vl = _symbols[offset + 2];
					final ArrayList vl = (ArrayList) _symbol_vl.value;
					 return new Symbol(vl);
			}
			case 54: // varformals = empty
			{
					 return new Symbol(new ArrayList());
			}
			case 55: // var_list = one_var.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final Var v = (Var) _symbol_v.value;
					 ArrayList vl = new ArrayList(); vl.add(v); return new Symbol(vl);
			}
			case 56: // var_list = var_list.vl COMMA one_var.v
			{
					final Symbol _symbol_vl = _symbols[offset + 1];
					final ArrayList vl = (ArrayList) _symbol_vl.value;
					final Symbol _symbol_v = _symbols[offset + 3];
					final Var v = (Var) _symbol_v.value;
					 vl.add(v); return new Symbol(vl);
			}
			case 57: // var_list = empty
			{
					 new Symbol( new ArrayList() );
			}
			case 58: // one_var = VAR ID.id COLON TYPE.t
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final String t = (String) _symbol_t.value;
					 return new Var(id, t);
			}
			case 59: // have_extends = EXTENDS type_or_native.ext
			{
					final Symbol ext = _symbols[offset + 2];
					 return ext;
			}
			case 61: // type_or_native = TYPE.t actuals.a
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList a = (ArrayList) _symbol_a.value;
					 return new Extends(t, a);
			}
			case 62: // type_or_native = NATIVE
			{
					 return new Extends();
			}
			case 63: // actuals = LPAREN exp_list.el RPAREN
			{
					final Symbol _symbol_el = _symbols[offset + 2];
					final ArrayList el = (ArrayList) _symbol_el.value;
					 return new Symbol(el);
			}
			case 64: // exp_list = expr.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 ArrayList el = new ArrayList(); el.add(e); return new Symbol(el);
			}
			case 65: // exp_list = exp_list.el COMMA expr.e
			{
					final Symbol _symbol_el = _symbols[offset + 1];
					final ArrayList el = (ArrayList) _symbol_el.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 el.add(e); return new Symbol(el);
			}
			case 66: // exp_list = empty
			{
					 return new Symbol( new ArrayList() );
			}
			case 67: // classbody = LBRACE feature_list.fl RBRACE
			{
					final Symbol _symbol_fl = _symbols[offset + 2];
					final ArrayList fl = (ArrayList) _symbol_fl.value;
					 return new Symbol(fl);
			}
			case 68: // feature_list = feature.f feature_list.fl
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Feature f = (Feature) _symbol_f.value;
					final Symbol _symbol_fl = _symbols[offset + 2];
					final ArrayList fl = (ArrayList) _symbol_fl.value;
					 fl.add(f); return new Symbol(fl);
			}
			case 69: // feature_list = empty
			{
					 return new Symbol( new ArrayList() );
			}
			case 70: // feature = OVERRIDE DEF ID.id formals.fl COLON TYPE.t ASSIGN expr_or_native.e SEMI
			{
					final Symbol _symbol_id = _symbols[offset + 3];
					final String id = (String) _symbol_id.value;
					final Symbol fl = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 6];
					final String t = (String) _symbol_t.value;
					final Symbol e = _symbols[offset + 8];
					 return new OverrideFeatureMethod(id, (ArrayList)fl.value, t, (Expr)e);
			}
			case 71: // feature = DEF ID.id formals.fl COLON TYPE.t ASSIGN expr_or_native.e SEMI
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol fl = _symbols[offset + 3];
					final Symbol _symbol_t = _symbols[offset + 5];
					final String t = (String) _symbol_t.value;
					final Symbol e = _symbols[offset + 7];
					 return new FeatureMethod(id, (ArrayList)fl.value, t, (Expr)e);
			}
			case 72: // feature = VAR ID.id ASSIGN NATIVE SEMI
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					 return new FeatureVar(id );
			}
			case 73: // feature = VAR ID.id COLON TYPE.t ASSIGN expr.e SEMI
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_e = _symbols[offset + 6];
					final Expr e = (Expr) _symbol_e.value;
					 return new FeatureVar(id, t, e );
			}
			case 74: // feature = LBRACE block.b RBRACE SEMI
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return new FeatureBlock(b);
			}
			case 75: // expr_or_native = expr.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 77: // formals = LPAREN formal_list.fl RPAREN
			{
					final Symbol _symbol_fl = _symbols[offset + 2];
					final ArrayList fl = (ArrayList) _symbol_fl.value;
					 return new Symbol(fl);
			}
			case 78: // formal_list = formal.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Formal f = (Formal) _symbol_f.value;
					 ArrayList fl = new ArrayList(); fl.add(f); return new Symbol(fl);
			}
			case 79: // formal_list = formal_list.fl COMMA formal.f
			{
					final Symbol _symbol_fl = _symbols[offset + 1];
					final ArrayList fl = (ArrayList) _symbol_fl.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Formal f = (Formal) _symbol_f.value;
					 fl.add(f); return new Symbol(fl);
			}
			case 80: // formal_list = empty
			{
					 return new Symbol( new ArrayList() );
			}
			case 81: // formal = ID.id COLON TYPE.t
			{
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final String t = (String) _symbol_t.value;
					  return new Formal(id,t);
			}
			case 33: // opt$actuals = 
			case 49: // empty = 
			{
				return new Symbol(null);
			}
			case 3: // program = bogus
			case 34: // opt$actuals = actuals
			case 60: // have_extends = empty
			case 76: // expr_or_native = NATIVE
			{
				return _symbols[offset + 1];
			}
			case 50: // bogus = STUB CLASS EXTENDS VAR OVERRIDE DEF NATIVE NEW NULL THIS CASE MATCH IF ELSE WHILE SUPER LPAREN RPAREN LBRACE RBRACE COLON COMMA ASSIGN SEMI ARROW DOT PLUS MINUS TIMES DIV LE LT EQUALS NOT TYPE ID INTEGER STRING BOOLEAN
			{
				return _symbols[offset + 39];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
