package cool.parser;

import java.util.ArrayList;
import beaver.*;
import cool.parser.ast.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "cool.grammar".
 */
public class SimpleParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjc0cO5SKHnslclRVi0Wi1EGJtO3aZuYB82ek82oXWZAZ1U8j4WoSQG#8TemOJZmHleZd" +
		"4MuaQmOi550ILGpbMK0GKuv68WYQAQ4mqiVrrTSymR$Q9#9byCNw#$lvrJLLtLNNlxCo859" +
		"rXvkUD1fdg9MFcomGvJ$h8J#KigJN$YdoagMcmdkfzA9mXOy6ju0zEZuQVOG$LdWUhvIwpM" +
		"kNLo1DaJ#cZ#khay57dg6QlDSWqSBIVzMCPBdkX5wNMoahE$5kAOykVt91cIdj9Sw#t05ig" +
		"ky2y47kELDb6lkg6D54wGrfv$I6ehUg7HDyeBQKqyZIFM1yfaGgpmWrYBMqft$3wP72qJ99" +
		"gQIszgU78sFCwQbaXlqLkaDF0C6e9vGJvFYlzc9N6cuVbT3bElYa$abFaLFc1PCmoSw$yIZ" +
		"f9N$Eq7msModPoezFbbo2gStTclIZob4FKrs4PUTdkJJ9pf3MyJQCT$0apJ5JvGUYBRaXRv" +
		"Klb0Q#tWywMzhAzcGE$czsAF8VBCT2EoElycALqgUVhp6pmADIYmJm4lATSeh92gl2tESqo" +
		"3rf9kkHdQkP9Dp16CtLTF5g#grtSaHnkal7ICx#B#FIIdMHNsqLwyh8RKgDqZ9Hvoqoqeyn" +
		"S#5pvEJ6$Y3qFaTlX6zsGEvMEaLxUCXFjMEXz5Z94XaQUPWdvRPHXvYdPs#Pdfictm7ZPBv" +
		"NV$MQwXUxo6jaNVDiiCMlWzn3xH$Z#LakCnMQXmifhBUGW6OMqrZnfdWDhPRHgMyOYEHWSP" +
		"cKv7Fgc7yzQAaUObKwNxq6VaN5oafn1ryuq3tXxdPmifybtwFObSh5s#rAvN2wZcecfCtk5" +
		"N2jNoPLQpGOtvDTAhvRhlQKUxJVoErCllvSfShFS4dlUPXR0NtU37bjwXtdSM#h13EXZO8P" +
		"vWlj5v7clJ8U$uORSh$G#gVVwJEWCcIspe7F0mx7dN7aKljuDUKJfF9dlzSV0u$A4B9H5ia" +
		"0MovEnvrEo1FwQ6x9KwJ9PxlMdGOEia9Noh3mdpyYgs7Erh8N$nGrvNkaBiiRhww3B9V6BF" +
		"PtyPpUGbJhkTCdxUNkTbwFxd3ZgkDDJSR6dog#uWQpKSQUdufozpiilkO6ir76df#9YJ$vM" +
		"Nk9qsPyzNUut7kIVhkXd$vPFW#T7b1MCS7usOkipVrNyuWwPlxf1dvKwxlJKFZXxNO6UVjO" +
		"QRxd174eTTtfg3MUlY#uzM9GwxlHKH7Jl#VnPlUC6SoXrtEcfDTwHmNAkUTiDTAMEEptb$x" +
		"Rw$yqDTAMEEpq$MtJy2sIxRJLzxHLvbSk1$bdkUFcPz93#Sg5vrxmhPmDHIHpt#YQpYMkRP" +
		"6UL1c7Rf99OvCqsI6VR8SycQXiX7GfOTqWSXtrYwPe2dbqBsBeNiErImBQRUT#yJxOAInrN" +
		"QM01$mFCPhCP7uMbZgjKoFz4yvvv3n#5fOwhLCZ$1fuHaxPARFcMpeqi$QI$#S1ymCmAIrK" +
		"U8EURZyn7o0h6FnbGD2jzo82YMUaV32YQbVxEWA9PQHK3YhRAKiibuAawOzyJf4YQGAkbgJ" +
		"IJvbnimNdQaUV3dNYssHczdNsIPO$t9AQCc0gyIuWfXfOYTu4MssTxQSNJ$7RIHjh6CtJa7" +
		"0JqASDgELPpKUvgAP6V5LMkcRaeuUcq7r7LgQZTwAZjT4SzS#LnPNLQMJ4pkCg2L6L1N9dr" +
		"AoEs8exjghOUSLUgYGryT4vgsVieDk1Q6NUlTAprSR7bn5PplmtP#wpM4CLMQ6mLFDeBMqk" +
		"oGq6grk5aEP8ero4N5UXwdU8wzyYhC#2vEbglIM87xL#TNQcJdibIf49xKQmhLIUwkhi$Bm" +
		"FyQbNQcKhcx8fr6BxHQhRIChmhKfbsYJErdGd984i68TUoSMn98jFYEDCYpJHCPHeoMzRt9" +
		"3enDHhHmP#OT6q1L$lwsfh4sOMQNRLqIvoN6dzkGxHiee#LP1V5TVDnnOcgQkBzBc6bA2w7" +
		"VnaqfncK#9fBwM6weX1xDb5H2Lrp4Lqqek8p8tBac5nZIAC8Mr6LHbGczjVjKNUugwQxxcz" +
		"VhbPgrwhYQa9VJGadpgvK1IeBt0liYQdqAqMhbEWg5NczjbuvR4MQGxJA26nRUbsiSNtpJb" +
		"2WPx#prbmUnmrWZIrnbHfNnHbrSLs8AoUcdDYMy4vnN2cvf$VMtXrSN4VYcb97CTTRwJv6S" +
		"LLuRuchqBWYkkVYsX7NWIljqLhWtpoEQvsNvtOQruPyNLnRlCKaVb6Sod4SCd5gqpXu2sF#" +
		"l#FSwL8RfyjVBGLvfokEqvCFpujW$mf4E3#DsEhCNnM$H8S#zpuqxkb$OOqlOrR$GV$yRBr" +
		"$esothQQllHezBTfdkMhfpVj1dwtkGdIFtKlliUtoTpHljdP#jeGD3sSRLCYQE0r3OwcWvn" +
		"UoKG5ouUh#5$wDRTjY#PHLykswMqs$gEPd5tdn0lV#UJAmxpXjmANWC72yVqEj1A6uBqZhm" +
		"FNWB94W1xVV5cy5Ay5Y#mA5lHd8W6B06i49e1fq0xof1mVXTvb8XlcBHgBlXtmk$0Zu5V0Z" +
		"uSnPj3yu69rSWbF0cSHD1Gj0lLOWcNhiGz5VXf#DlWH#CVmbOey2lBbd7n39hOKlX9y4jp9" +
		"pPT$2ZxV4u6vmCxY8UQm#5zm4PgBJdc05c0CsWkNWTa2zmNpcQ0L$c$OqWR$9UlOBn6RNhg" +
		"AJzHrHWbV1ws03UWVuULodHs5BVSULm7u1ejRWEcnjtTUBe3se8TzDsEX$o3pXG40$mWdWS" +
		"d0NeAOiVGXP8$mO$zRKr95OwWYjl1iszYf7xxFqDZS0tWli3Uv4tvSyUOCCZWLN0zwZWic0" +
		"D#kGDxzW6fnz33aRmJom52n3hmBC6P9dk3teobgZuBjmlHREkd8Rl0BOFRyIlXFW76JPtt0" +
		"4i6jHTyZ#XvopaDu5z3iy08m6XuDZm3ZcOhx0riNU1GzXOwtWDJXdA#HyX8UYhmVl0leGpC" +
		"9s2B1h7GV60ivRU2eu0vmFx3xGav2p5ru8hW4JWStLxiKKS0Eu1N2cGlOzl0hS0oO1paZ8k" +
		"GavWw6jzGvm7#2yXRPlzuFfu170MGfd0yvMkCh$pKs#m1qm##iToLu$aUFzFBoFrySbhfsP" +
		"zFMsL$BrtDYqZxT$k4KkodZRPPvVszW$6EMlrIRcc9BlKzJSswT6Dd9Vx$DQv7aJpzibvfx" +
		"eRJqISvzKAEzK3VCISzHxFl3J$UtzB1XJm6xFoJa#$hNK6cksdeDCICXt9lBPaB1tzloDLE" +
		"peb3wzK7pXTOCFy$NSwLlpJ$YzavYZBlzQMEfvhrHUgRp30TkorfSL$dUWZEG$ONzkqFtXL" +
		"kx3iu$z3z#R$v6zUMlehNA6$ySH0fvyClfTh1VS8U0$TyOZu3zvniFAeUT1IhSygtuzqNkY" +
		"MzuFtW##AtQ7G8RoFte8SWqvrP1JZNvZomBxLKrakFJWZfYJmSGEncymzc6AZF81#Ex9DVj" +
		"bSWHyX7wfoF245m37w#03kJOGkPQdxrgUAMlr6vxzHfVbAIrGx8xVtlgrpF4zuFjy0jDSdh" +
		"K=");

	public SimpleParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // program = class_list.cl
			{
					final Symbol _symbol_cl = _symbols[offset + 1];
					final ArrayList cl = (ArrayList) _symbol_cl.value;
					 return new Symbol(cl);
			}
			case 1: // class_list = classdecl.cd class_list.cl
			{
					final Symbol cd = _symbols[offset + 1];
					final Symbol _symbol_cl = _symbols[offset + 2];
					final ArrayList cl = (ArrayList) _symbol_cl.value;
					 cl.add(cd); return new Symbol(cl);
			}
			case 2: // class_list = empty
			{
					 return new Symbol( new ArrayList() );
			}
			case 4: // expr = lexpr.le ASSIGN rexpr.re
			{
					final Symbol le = _symbols[offset + 1];
					final Symbol _symbol_re = _symbols[offset + 3];
					final Expr re = (Expr) _symbol_re.value;
					 ArrayList operands = new ArrayList(); operands.add(le); operands.add(re); return new AssignmentOperation(operands);
			}
			case 5: // expr = rexpr.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final Expr r = (Expr) _symbol_r.value;
					 return r;
			}
			case 6: // rexpr = IF LPAREN rexpr.cond RPAREN expr.m ELSE expr.e
			{
					final Symbol _symbol_cond = _symbols[offset + 3];
					final Expr cond = (Expr) _symbol_cond.value;
					final Symbol _symbol_m = _symbols[offset + 5];
					final Expr m = (Expr) _symbol_m.value;
					final Symbol _symbol_e = _symbols[offset + 7];
					final Expr e = (Expr) _symbol_e.value;
					 return new IfNode( cond, m, e);
			}
			case 7: // rexpr = WHILE LPAREN rexpr.cond RPAREN expr.e
			{
					final Symbol _symbol_cond = _symbols[offset + 3];
					final Expr cond = (Expr) _symbol_cond.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					 return new WhileNode( cond, e);
			}
			case 8: // rexpr = rel.r
			{
					final Symbol r = _symbols[offset + 1];
					 return r;
			}
			case 9: // rexpr = primary.p MATCH cases.c
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 3];
					final ArrayList c = (ArrayList) _symbol_c.value;
					 Expr e = (Expr) p.value; return new Match(e, c);
			}
			case 10: // rel = rel.r LE equiv.e
			{
					final Symbol r = _symbols[offset + 1];
					final Symbol e = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(r); operands.add(e); return new LessOrEqual(operands);
			}
			case 11: // rel = rel.r LT equiv.e
			{
					final Symbol r = _symbols[offset + 1];
					final Symbol e = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(r); operands.add(e); return new LessThan(operands);
			}
			case 12: // rel = equiv.e
			{
					final Symbol e = _symbols[offset + 1];
					 return e;
			}
			case 13: // equiv = equiv.e EQUALS sum.s
			{
					final Symbol e = _symbols[offset + 1];
					final Symbol s = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(e); operands.add(s); return new Equal(operands);
			}
			case 14: // equiv = sum.s
			{
					final Symbol s = _symbols[offset + 1];
					 return s;
			}
			case 15: // sum = sum.s PLUS product.p
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol p = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(s); operands.add(p); return new PlusOperation(operands);
			}
			case 16: // sum = sum.s MINUS product.p
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol p = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(s); operands.add(p); return new MinusOperation(operands);
			}
			case 17: // sum = product.p
			{
					final Symbol p = _symbols[offset + 1];
					 return p;
			}
			case 18: // product = product.p TIMES primary.i
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol i = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(p); operands.add(i); return new MultiplyOperation(operands);
			}
			case 19: // product = product.p DIV primary.i
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol i = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(p); operands.add(i); return new DivisionOperation(operands);
			}
			case 20: // product = primary.p
			{
					final Symbol p = _symbols[offset + 1];
					 return p;
			}
			case 21: // primary = LBRACE block.b RBRACE
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return (Expr)b;
			}
			case 22: // primary = LPAREN expr.e RPAREN
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 23: // primary = NULL
			{
					 return new NullNode();
			}
			case 24: // primary = LPAREN RPAREN
			{
					 return new Unit();
			}
			case 25: // primary = INTEGER.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					 return new IntegerNode(Integer.parseInt(i));
			}
			case 26: // primary = STRING.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final String s = (String) _symbol_s.value;
					 return new StringNode(s);
			}
			case 27: // primary = BOOLEAN.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Boolean b = (Boolean) _symbol_b.value;
					 return new BooleanNode(b);
			}
			case 28: // primary = MINUS primary.p
			{
					final Symbol p = _symbols[offset + 2];
					 ArrayList operands = new ArrayList() ; operands.add(p); return new UnaryMinusOperation(operands);
			}
			case 29: // primary = lexpr.e
			{
					final Symbol e = _symbols[offset + 1];
					 return e;
			}
			case 30: // primary = NOT primary.p
			{
					final Symbol p = _symbols[offset + 2];
					 ArrayList operands = new ArrayList() ; operands.add(p); return new UnaryNotOperation(operands);
			}
			case 31: // primary = primary.p DOT ID.id actuals.a
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol _symbol_id = _symbols[offset + 3];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final ArrayList a = (ArrayList) _symbol_a.value;
					 Primary pp = (Primary)p.value ; return new PrimaryActual(a,pp, id);
			}
			case 32: // primary = NEW TYPE.t actuals.s
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_s = _symbols[offset + 3];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Instance(t,s);
			}
			case 33: // ident = ID.id
			{
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					 return new Id(id);
			}
			case 34: // ident = ID.id actuals.s
			{
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Method(id,s);
			}
			case 35: // ident = THIS
			{
					 return new Id("this");
			}
			case 36: // block = st_list.el expr.e
			{
					final Symbol el = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 ArrayList es = (ArrayList) el.value; return new Block(es , e);
			}
			case 37: // block = empty
			{
					 return new Block();
			}
			case 38: // st_list = st_list.el new_var.ve SEMI
			{
					final Symbol el = _symbols[offset + 1];
					final Symbol ve = _symbols[offset + 2];
					 ArrayList es = (ArrayList) el.value; es.add(ve); return new Symbol(es);
			}
			case 39: // st_list = st_list.el expr.e SEMI
			{
					final Symbol el = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 ArrayList es = (ArrayList) el.value; es.add(e); return new Symbol(es);
			}
			case 40: // st_list = empty
			{
					 ArrayList el  = new ArrayList(); return new Symbol(el);
			}
			case 41: // new_var = VAR ID.id COLON TYPE.t ASSIGN expr.e
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_e = _symbols[offset + 6];
					final Expr e = (Expr) _symbol_e.value;
					 return new VarExpr( id, t, e);
			}
			case 42: // cases = LBRACE case_block.cb RBRACE
			{
					final Symbol _symbol_cb = _symbols[offset + 2];
					final ArrayList cb = (ArrayList) _symbol_cb.value;
					 return new Symbol(cb);
			}
			case 43: // case_block = CASE ID.id COLON TYPE.t ARROW block.b case_block.cb
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_cb = _symbols[offset + 7];
					final ArrayList cb = (ArrayList) _symbol_cb.value;
					 cb.add(new Case(id,t,b));return new Symbol(cb);
			}
			case 44: // case_block = CASE NULL ARROW block.b case_block.cb
			{
					final Symbol _symbol_b = _symbols[offset + 4];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_cb = _symbols[offset + 5];
					final ArrayList cb = (ArrayList) _symbol_cb.value;
					 cb.add(new Case(b));return new Symbol(cb);
			}
			case 45: // case_block = empty
			{
					 return new Symbol(new ArrayList());
			}
			case 46: // lexpr = SUPER DOT ID.id actuals.a
			{
					final Symbol _symbol_id = _symbols[offset + 3];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final ArrayList a = (ArrayList) _symbol_a.value;
					 return new SuperActual(id,a);
			}
			case 47: // lexpr = ident.id
			{
					final Symbol _symbol_id = _symbols[offset + 1];
					final Id id = (Id) _symbol_id.value;
					 return id;
			}
			case 50: // classdecl = CLASS TYPE.t varformals.v have_extends.e classbody.fl
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_v = _symbols[offset + 3];
					final ArrayList v = (ArrayList) _symbol_v.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Extends e = (Extends) _symbol_e.value;
					final Symbol fl = _symbols[offset + 5];
					 return new ClassNode(t, v, e, (ArrayList)fl.value);
			}
			case 51: // varformals = LPAREN RPAREN
			{
					 return new Symbol(new ArrayList());
			}
			case 52: // varformals = LPAREN var_list.vl RPAREN
			{
					final Symbol _symbol_vl = _symbols[offset + 2];
					final ArrayList vl = (ArrayList) _symbol_vl.value;
					 return new Symbol(vl);
			}
			case 53: // varformals = empty
			{
					 return new Symbol(new ArrayList());
			}
			case 54: // var_list = one_var.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final Var v = (Var) _symbol_v.value;
					 ArrayList vl = new ArrayList(); vl.add(v); return new Symbol(vl);
			}
			case 55: // var_list = var_list.vl COMMA one_var.v
			{
					final Symbol _symbol_vl = _symbols[offset + 1];
					final ArrayList vl = (ArrayList) _symbol_vl.value;
					final Symbol _symbol_v = _symbols[offset + 3];
					final Var v = (Var) _symbol_v.value;
					 vl.add(v); return new Symbol(vl);
			}
			case 56: // var_list = empty
			{
					 new Symbol( new ArrayList() );
			}
			case 57: // one_var = VAR ID.id COLON TYPE.t
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final String t = (String) _symbol_t.value;
					 return new Var(id, t);
			}
			case 58: // have_extends = EXTENDS type_or_native.ext
			{
					final Symbol ext = _symbols[offset + 2];
					 return ext;
			}
			case 60: // type_or_native = TYPE.t actuals.a
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList a = (ArrayList) _symbol_a.value;
					 return new Extends(t, a);
			}
			case 61: // type_or_native = NATIVE
			{
					 return new Extends();
			}
			case 62: // actuals = LPAREN exp_list.el RPAREN
			{
					final Symbol _symbol_el = _symbols[offset + 2];
					final ArrayList el = (ArrayList) _symbol_el.value;
					 return new Symbol(el);
			}
			case 63: // exp_list = expr.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 ArrayList el = new ArrayList(); el.add(e); return new Symbol(el);
			}
			case 64: // exp_list = exp_list.el COMMA expr.e
			{
					final Symbol _symbol_el = _symbols[offset + 1];
					final ArrayList el = (ArrayList) _symbol_el.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 el.add(e); return new Symbol(el);
			}
			case 65: // exp_list = empty
			{
					 return new Symbol( new ArrayList() );
			}
			case 66: // classbody = LBRACE feature_list.fl RBRACE
			{
					final Symbol _symbol_fl = _symbols[offset + 2];
					final ArrayList fl = (ArrayList) _symbol_fl.value;
					 return new Symbol(fl);
			}
			case 67: // feature_list = feature.f feature_list.fl
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Feature f = (Feature) _symbol_f.value;
					final Symbol _symbol_fl = _symbols[offset + 2];
					final ArrayList fl = (ArrayList) _symbol_fl.value;
					 fl.add(f); return new Symbol(fl);
			}
			case 68: // feature_list = empty
			{
					 return new Symbol( new ArrayList() );
			}
			case 69: // feature = OVERRIDE DEF ID.id formals.fl COLON TYPE.t ASSIGN expr_or_native.e SEMI
			{
					final Symbol _symbol_id = _symbols[offset + 3];
					final String id = (String) _symbol_id.value;
					final Symbol fl = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 6];
					final String t = (String) _symbol_t.value;
					final Symbol e = _symbols[offset + 8];
					 return new OverrideFeatureMethod(id, (ArrayList)fl.value, t, (Expr)e);
			}
			case 70: // feature = DEF ID.id formals.fl COLON TYPE.t ASSIGN expr_or_native.e SEMI
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol fl = _symbols[offset + 3];
					final Symbol _symbol_t = _symbols[offset + 5];
					final String t = (String) _symbol_t.value;
					final Symbol e = _symbols[offset + 7];
					 return new FeatureMethod(id, (ArrayList)fl.value, t, (Expr)e);
			}
			case 71: // feature = VAR ID.id ASSIGN NATIVE SEMI
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					 return new FeatureVar(id );
			}
			case 72: // feature = VAR ID.id COLON TYPE.t ASSIGN expr.e SEMI
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_e = _symbols[offset + 6];
					final Expr e = (Expr) _symbol_e.value;
					 return new FeatureVar(id, t, e );
			}
			case 73: // feature = LBRACE block.b RBRACE SEMI
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return new FeatureBlock(b);
			}
			case 74: // expr_or_native = expr.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 76: // formals = LPAREN formal_list.fl RPAREN
			{
					final Symbol _symbol_fl = _symbols[offset + 2];
					final ArrayList fl = (ArrayList) _symbol_fl.value;
					 return new Symbol(fl);
			}
			case 77: // formal_list = formal.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Formal f = (Formal) _symbol_f.value;
					 ArrayList fl = new ArrayList(); fl.add(f); return new Symbol(fl);
			}
			case 78: // formal_list = formal_list.fl COMMA formal.f
			{
					final Symbol _symbol_fl = _symbols[offset + 1];
					final ArrayList fl = (ArrayList) _symbol_fl.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Formal f = (Formal) _symbol_f.value;
					 fl.add(f); return new Symbol(fl);
			}
			case 79: // formal_list = empty
			{
					 return new Symbol( new ArrayList() );
			}
			case 80: // formal = ID.id COLON TYPE.t
			{
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final String t = (String) _symbol_t.value;
					  return new Formal(id,t);
			}
			case 48: // empty = 
			{
				return new Symbol(null);
			}
			case 3: // program = bogus
			case 59: // have_extends = empty
			case 75: // expr_or_native = NATIVE
			{
				return _symbols[offset + 1];
			}
			case 49: // bogus = STUB CLASS EXTENDS VAR OVERRIDE DEF NATIVE NEW NULL THIS CASE MATCH IF ELSE WHILE SUPER LPAREN RPAREN LBRACE RBRACE COLON COMMA ASSIGN SEMI ARROW DOT PLUS MINUS TIMES DIV LE LT EQUALS NOT TYPE ID INTEGER STRING BOOLEAN
			{
				return _symbols[offset + 39];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
